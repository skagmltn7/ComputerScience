# Abstract class
```java
public abstract class A{
	int a;
	public methodA(){
		System.out.println("인스턴스 메소드");
	}
	public abstract methodB(); 
}
```
- 하나 이상의 추상 메소드를 가진 클래스
  - 클래스이기 때문에 클래스의 요소는 다 가질 수 있음(생성자, 변수, 메소드 등)
  - **다중 상속X**
- 미완성된 메소드가 있기 때문에 **추상클래스는 인스턴스화X**
### 추상 클래스의 활용
- **공통 멤버의 통합으로 중복 제거**
  - 하위클래스들의 공통 멤버를 상위 클래스에서 구현하여 코드 중복 제거
- **상속받는 자식 클래스에 구현을 강제**
  - 추상 메소드를 오버라이드해야만 인스턴스화 가능
  - 일반 클래스를 상속하는 경우, 오버라이드하지 않아도 인스턴스화 가능

# Interface
```java
interface C{
	int c; // public static final 생략
	void methodC(); // public abstract 생략
    default public void methodD(){
        System.out.println("인터페이스의 디폴트 메서드 입니다.");
    }
}
```
- 하나 이상의 추상 메소드와 독립 상수를 가진 인터페이스
  - **다중상속O**
  - 자바 8에서 하위 호환성을 위한 **default메소드와 static 메소드** 추가
    - 공통으로 구현해야하는 메소드가 있는데 인터페이스를 상속하다보니 하위 인터페이스에 모두 구현하는게 번거로움
  - 자바 9에서 인터페이스의 캡슐화를 위한 **private 메소드** 추가
- 인스턴스화X

## default 메소드 다중 상속 문제
- 클래스가 다중상속을 할 수 없었던 이유
  - 각기 다른 상위 클래스에서 같은 이름의 메소드를 가지고 있는 경우 상속 클래스의 모호함때문
- 자바 8이후 디폴트 메소드로 인하여 인터페이스에서도 같은 문제가 발생
- 추상메소드의 경우 구현되어있지 않기 때문에 구현을 강제하기때문에 상속의 모호성이 없었음
- **해결방안**
  - **여러 인터페이스에 같은 이름의 디폴트 메소드가 있는 경우**
    - 구현체에서 오버라이드한 같은 이름의 디폴트 메소드 사용
    - 오버라이드하지 않는 경우 컴파일오류
  - **인터페이스의 디폴드 메소드와 상속받은 상위클래스의 메소드와 이름이 같은 경우**
    - 상위 클래스의 메소드 사용
    - 디폴트 메소드를 사용해야한다면 구현체에서 오버라이드
***
# 차이점
**다중상속의 유무**
- `추상 클래스`는 다중상속이 불가능하고 `인터페이스`는 다중상속이 가능하다
  
**상태의 유무**
- `추상 클래스`는 멤버 변수, 일반 메소드, 생성자 등 상태를 가질 수 있다. 그러나 `인터페이스`는 상태를 가질 수 없다.
  
**사용 의도**
- `추상 클래스`는 is-a 관계가 성립할 때 사용하고, `인터페이스`는 has-a 관계가 성립할 때 사용한다.
